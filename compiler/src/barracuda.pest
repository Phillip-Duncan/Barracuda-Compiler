WHITESPACE = _{ " " | "\n" | "\t" | "\r" }
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" | "//" ~ (!"\n" ~ ANY)*}

// Literal Definitions
decimal = @{ ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
    ~ "." ~ ASCII_DIGIT*
    ~ (^"e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

integer = @{
    ("0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT*)
}

boolean = @ {
    "false" | "true"
}

string = ${ "\"" ~ inner ~ "\"" }
inner = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

identifier_char = _{
    ASCII_ALPHANUMERIC | "_"
}

identifier = @{ASCII_ALPHA ~ identifier_char*}
reference = @{ "&" ~ identifier }
variable = @{ "*"* ~ identifier }
literal = _{decimal | integer | boolean | string}

func_arg = {expression}
func_call = {identifier ~ "(" ~ ")" |
             identifier ~ "(" ~ (func_arg ~ ("," ~ func_arg)*) ~ ")"}

// Operator Definitions
equality_operator = _{equal | not_equal}
comparison_operator = _{greater_equal | less_equal | greater_than | less_than} // Must put <= and >= before < and > so the parser matches them first.
term_operator = _{add | sub}
factor_operator = _{div | mul | modulus}
exponent_operator = _{pow}
unary_operator = _{unary_not | unary_neg}

unary_not = {"!"}
unary_neg = {"-"}

add = {"+"}
sub = {"-"}
div = {"/"}
mul = {"*"}
modulus = {"%"}
pow = {"^"}
addr = {"&"}

equal = {"=="}
not_equal = {"!="}
greater_than = {">"}
less_than = {"<"}
greater_equal = {">="}
less_equal = {"<="}

// Operator precedence expression flow
expression = _{ equality }
equality   = { comparison ~ ( equality_operator ~ comparison )* }
comparison = { term ~ ( comparison_operator ~ term )* }
term       = { factor ~ ( term_operator ~ factor )* }
factor     = { exponent ~ ( factor_operator ~ exponent )* }
exponent   = { unary ~ (exponent_operator ~ unary)* }
unary      = { unary_operator ~ unary | primary }
primary    = _{ literal | func_call | reference | variable | "("~expression~")" }

// Statements that can be in global scope (or function scope)
global_statement = _{func_statement | if_statement | for_statement | while_statement
    | construct_statement ~ ";" | return_statement ~ ";" | assign_statement ~ ";" | print_statement  ~ ";"
    | external_statement ~ ";"}

global_statement_list = {global_statement*}
global_scope_block = {"{" ~  global_statement_list ~ "}"}

// Statements that can be in any scope
statement = _{if_statement | for_statement | while_statement
    | return_statement ~ ";" | assign_statement ~ ";" | print_statement  ~ ";"}

statement_list = {statement*}
scope_block = {"{" ~  statement_list ~ "}"}

construct_statement = {"let " ~ variable ~ "=" ~ expression
                       // | "let " ~ variable ~ ":" ~ datatype ~ "=" ~ expression //Currently datatypes are not functional.
                       // | "let " ~ variable ~ ":" ~ datatype  //Currently the 'expression' part of a construct statement is required.
                    }

// Define environment variable
external_statement = {"extern " ~ identifier}


assign_statement = {variable ~ "=" ~ expression}
datatype = _{identifier}

print_statement = {"print" ~ expression}

// Control Flow
if_statement = {"if" ~ expression ~ scope_block ~ ( ("else" ~ scope_block) | ("else" ~ if_statement))?}
for_statement = {"for" ~ "(" ~ construct_statement ~ ";" ~ expression ~ ";" ~ assign_statement ~ ")" ~ scope_block}
while_statement = {"while" ~ expression ~ scope_block}

func_param = {identifier ~ ":" ~ datatype | identifier}
func_statement = {"fn" ~ identifier ~ "("~ (func_param ~ ("," ~ func_param)* )? ~ ")" ~ (":" ~ datatype)? ~ global_scope_block }
return_statement = {"return" ~ expression}


// Program
program = _{ SOI ~ global_statement_list ~ EOI }